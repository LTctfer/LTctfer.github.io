---
title: XYCTF2024 WP
date: 2024-05-08 15:27:45
---

也是打了一下XYCTF的密码题，感觉好多题目都不是很熟悉，不过还是有几道做出来的，看了官方WP，有道题构造格的方法还挺好，可惜当时没想到，索性把现在搞懂了的题目先写一下

[TOC]

#### 1.sign1n(签到)

题目源代码：

```
from Crypto.Util.number import *
from tqdm import *
import gmpy2
flag=b'XYCTF{uuid}'
flag=bytes_to_long(flag)
leak=bin(int(flag))
while 1:
    leak += "0"
    if len(leak) == 514:
        break

def swap_bits(input_str):
    input_list = list(input_str[2:])
    length = len(input_list)

    for i in range(length // 2):
        temp = input_list[i]
        input_list[i] = input_list[length - 1 - i]
        input_list[length - 1 - i] = temp

    return ''.join(input_list)

input_str = leak
result = swap_bits(input_str)
a=result

def custom_add(input_str):
    input_list = list(input_str)
    length = len(input_list)
    
    for i in range(length):
        input_list[i] = str((int(input_list[i]) + i + 1) % 10)

    result = ''.join(input_list)
    return result


input_str = a
result = custom_add(input_str)
b=result
print(b)
#12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456799123455779912234567900134557889113346779901245568990233467780113455788901245667901134457889023345689001335668891123467799012455678012234568900133566889122356678011245578891223457790013356688901245667991134457899122355779001335668891123566789113445779912234677900123467889022356678011344567991223566890113455689911234677891224556899023
```

还是比较容易理解，先填充514位，然后首尾翻转，最后按位执行i+(n%10)的操作，所以逆向执行这三步即可解密

exp：

```
from Crypto.Util.number import *
def custom_subtract(input_str):
    input_list = list(input_str)
    length = len(input_list)
    

    for i in range(length):
        input_list[i] = str((int(input_list[i]) - i - 1) % 10)
    result = ''.join(input_list)
    return result

def swap_bits(input_str):
    input_list = list(input_str)
    length = len(input_list)

    for i in range(length // 2):
        temp = input_list[i]
        input_list[i] = input_list[length - 1 - i]
        input_list[length - 1 - i] = temp
    
    return ''.join(input_list)

b = '12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456799123455779912234567900134557889113346779901245568990233467780113455788901245667901134457889023345689001335668891123467799012455678012234568900133566889122356678011245578891223457790013356688901245667991134457899122355779001335668891123566789113445779912234677900123467889022356678011344567991223566890113455689911234677891224556899023'
a = custom_subtract(b)
leak = swap_bits(a)
leak = leak.rstrip('0')
flag = int(leak, 2)
flag = long_to_bytes(flag)
print(flag)


```

#### 2.happy to solve1

源代码：

```
from Crypto.Util.number import *
import sympy
from secrets import flag
def get_happy_prime():
  p = getPrime(512)
  q = sympy.nextprime(p ^ ((1 << 512) - 1))
  return p, q
m = bytes_to_long(flag)
p, q = get_happy_prime()
n = p * q
e = 65537
print(n)
print(pow(m, e, n))
\# 24852206647750545040640868093921252282805229864862413863025873203291042799096787789288461426555716785288286492530194901130042940279109598071958012303179823645151637759103558737126271435636657767272703908384802528366090871653024192321398785017073393201385586868836278447340624427705360349350604325533927890879
\# 14767985399473111932544176852718061186100743117407141435994374261886396781040934632110608219482140465671269958180849886097491653105939368395716596413352563005027867546585191103214650790884720729601171517615620202183534021987618146862260558624458833387692782722514796407503120297235224234298891794056695442287
```

由题意可以得到p+q≈2***512，p*q=n,通过方程推导也可得到p=p+q+sqrt{(p+q)^2-4*n}//2,，exp：

```
import gmpy2
from Crypto.Util.number import *
n =  24852206647750545040640868093921252282805229864862413863025873203291042799096787789288461426555716785288286492530194901130042940279109598071958012303179823645151637759103558737126271435636657767272703908384802528366090871653024192321398785017073393201385586868836278447340624427705360349350604325533927890879
c =  14767985399473111932544176852718061186100743117407141435994374261886396781040934632110608219482140465671269958180849886097491653105939368395716596413352563005027867546585191103214650790884720729601171517615620202183534021987618146862260558624458833387692782722514796407503120297235224234298891794056695442287
e = 65537
p=(2**512+gmpy2.iroot((2**512)**2-4*n,2)[0])//2
while n%p!=0:
    p=gmpy2.next_prime(p)
q=n//p
e=65537
d=gmpy2.invert(e,(p-1)*(q-1))
print(long_to_bytes(pow(c,d,n)))
```

除了上述方法，还有一种理解方式，即q是p与512位1异或，又因为phi_n = n - (p + q) + 1 ,且n位数与全1按位异或等于取反，原码 + 反码 = 2 ** n - 1
我们先不计q在nextprime函数后的差值，所以p + q = 2 ** 512 - 1
又因为素数性质（除2之外都是奇数），因此，p + q = 2 ** 512 - 1 + t
所以，爆破！这里的t从1开始，每次爆完t + 2，满足奇数条件，直到有符合的怕p + q的值便可得到flag

exp：

```
import gmpy2
from Crypto.Util.number import *

n =  24852206647750545040640868093921252282805229864862413863025873203291042799096787789288461426555716785288286492530194901130042940279109598071958012303179823645151637759103558737126271435636657767272703908384802528366090871653024192321398785017073393201385586868836278447340624427705360349350604325533927890879
c =  14767985399473111932544176852718061186100743117407141435994374261886396781040934632110608219482140465671269958180849886097491653105939368395716596413352563005027867546585191103214650790884720729601171517615620202183534021987618146862260558624458833387692782722514796407503120297235224234298891794056695442287
e = 65537
t = 1
for i in range(400):
    phi = n - (2**512 - 1 + t) + 1
    d = gmpy2.invert(e, phi)
    m = pow(c, d, n)
    print(long_to_bytes(m))
    t += 2
```

#### 3.factor1

源代码：

```
import gmpy2

import hashlib

from Crypto.Util.number import *

p = getPrime(512)

q = getPrime(512)

d = getPrime(512)

e = gmpy2.invert(d, (p**3 - 1) * (q**3 - 1))

flag = "XYCTF{" + hashlib.md5(str(p + q).encode()).hexdigest() + "}"

print(e)

print(p * q)

\# 172005065945326769176157335849432320425605083524943730546805772515111751580759726759492349719668775270727323745284785341119685198468883978645793770975366048506237371435027612758232099414404389043740306443065413069994232238075194102578269859784981454218948784071599231415554297361219709787507633404217550013282713899284609273532223781487419770338416653260109238572639243087280632577902857385265070736208291583497988891353312351322545840742380550393294960815728021248513046077985900158814037534487146730483099151396746751774427787635287611736111679074330407715700153025952858666841328055071403960165321273972935204988906850585454805923440635864200149694398767776539993952528995717480620593326867245714074205285828967234591508039849777840636255379730281105670496110061909219669860172557450779495125345533232776767292561378244884362014224844319802810586344516400297830227894063759083198761120293919537342405893653545157892446163

\# 99075185389443078008327214328328747792385153883836599753096971412377366865826254033534293886034828804219037466246175526347014045811852531994537520303063113985486063022444972761276531422538694915030159420989401280012025249129111871649831185047820236417385693285461420040134313833571949090757635806658958193793
```

题目意思还是比较明确的，可以先通过维纳攻击求出phi值，然后通过方程解出p+q的值，先解出phi exp：

```
import gmpy2
import libnum
from Crypto.Util.number import long_to_bytes


def transform(x, y):  # 使用辗转相处将分数 x/y 转为连分数的形式
    res = []
    while y:
        res.append(x // y)
        x, y = y, x % y
    return res

def continued_fraction(sub_res):
    numerator, denominator = 1, 0
    for i in sub_res[::-1]:  # 从sublist的后面往前循环
        denominator, numerator = numerator, i * numerator + denominator
    return denominator, numerator  # 得到渐进分数的分母和分子，并返回

def sub_fraction(x, y):
    res = transform(x, y)
    res = list(map(continued_fraction, (res[0:i] for i in range(1, len(res)))))  # 将连分数的结果逐一截取以求渐进分数
    return res


def get_pq(a, b, c):  # 由p+q和pq的值通过维达定理来求解p和q
    par = gmpy2.isqrt(b * b - 4 * a * c)  # 由上述可得，开根号一定是整数，因为有解
    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)
    return x1, x2


def wienerAttack(e, n):
    for (d, k) in sub_fraction(e, pow(n,3)):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数
        if k == 0:  # 可能会出现连分数的第一个为0的情况，排除
            continue
        if (e * d - 1) % k != 0:  # ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)
            continue

        phi = (e * d - 1) // k  # 这个结果就是 φ(n)
    
        print(phi)





e = 172005065945326769176157335849432320425605083524943730546805772515111751580759726759492349719668775270727323745284785341119685198468883978645793770975366048506237371435027612758232099414404389043740306443065413069994232238075194102578269859784981454218948784071599231415554297361219709787507633404217550013282713899284609273532223781487419770338416653260109238572639243087280632577902857385265070736208291583497988891353312351322545840742380550393294960815728021248513046077985900158814037534487146730483099151396746751774427787635287611736111679074330407715700153025952858666841328055071403960165321273972935204988906850585454805923440635864200149694398767776539993952528995717480620593326867245714074205285828967234591508039849777840636255379730281105670496110061909219669860172557450779495125345533232776767292561378244884362014224844319802810586344516400297830227894063759083198761120293919537342405893653545157892446163
n = 99075185389443078008327214328328747792385153883836599753096971412377366865826254033534293886034828804219037466246175526347014045811852531994537520303063113985486063022444972761276531422538694915030159420989401280012025249129111871649831185047820236417385693285461420040134313833571949090757635806658958193793
d = wienerAttack(e, n)
```

通过代码解出phi后，联系本题，很容易看出求出的phi=(p ** 3 - 1) * (q ** 3 - 1)，可以转化为phi=n ** 3 − (p+q) ** 3 + 3n * (p+q) + 1，使用sage求解即可，phi值求出来有4个，一个个带入即可

```
import sympy

phi=972511355325113364052631731298241810108224336674853638392467496531221801463760422905081649486798893513235333261259026447362914449581968126150102058615785246984679107185088051540510676300698365173661664885922445984655201183939191294572815083110772280365015589954234618105130449050794187936653858911777331129374894613360180493778922390477471639230901499329286970066470938409172561402078020835704490763798033121327637376099345951393869066421256289755264836484293517455899841236893445058111156336783915080237891217097045326088433225353906745033086359517592587665091898519726306522216078946862525938605393095583476688928534868739031136603910653270126346663043777160589940969589929595662661998764846989622496897301967409430643458710968400436993966533764128546870219134569546167184537791250407432987498639475713973006971493363603598769092342912760402244358599858957999731973699418392072577594301810589012112435730728238977588777556

n=99075185389443078008327214328328747792385153883836599753096971412377366865826254033534293886034828804219037466246175526347014045811852531994537520303063113985486063022444972761276531422538694915030159420989401280012025249129111871649831185047820236417385693285461420040134313833571949090757635806658958193793

x=sympy.Symbol('x')#x即为p+q

solved_value=sympy.solve([n**3-x**3+3*n*x+1-phi],[x])

print(solved_value)
```

#### 4.complex_dlp

源代码：

```
from Crypto.Util.number import *

from secrets import flag





class Complex:

  def __init__(self, re, im):

​    self.re = re

​    self.im = im



  def __mul__(self, c):

​    re_ = self.re * c.re - self.im * c.im

​    im_ = self.re * c.im + self.im * c.re

​    return Complex(re_, im_)



  def __str__(self):

​    if self.im == 0:

​      return str(self.re)

​    elif self.re == 0:

​      if abs(self.im) == 1:

​        return f"{'-' if self.im < 0 else ''}i"

​      else:

​        return f"{self.im}i"

​    else:

​      return f"{self.re} {'+' if self.im > 0 else '-'} {abs(self.im)}i"





def complex_pow(c, exp, n):

  result = Complex(1, 0)

  while exp > 0:

​    if exp & 1:

​      result = result * c

​      result.re = result.re % n

​      result.im = result.im % n

​    c = c * c

​    c.re = c.re % n

​    c.im = c.im % n

​    exp >>= 1

  return result





flag = flag.strip(b"XYCTF{").strip(b"}")

p = 1127236854942215744482170859284245684922507818478439319428888584898927520579579027

g = Complex(3, 7)

x = bytes_to_long(flag)

print(complex_pow(g, x, p))

\# 5699996596230726507553778181714315375600519769517892864468100565238657988087817 + 198037503897625840198829901785272602849546728822078622977599179234202360717671908i
```

这道题直接用复数的模长打dlp就行，exp：

```
from Crypto.Util.number import *
a=5699996596230726507553778181714315375600519769517892864468100565238657988087817

b=198037503897625840198829901785272602849546728822078622977599179234202360717671908

p=1127236854942215744482170859284245684922507818478439319428888584898927520579579027
G=GF(p^2)
base=G(3^2+7^2)
res=G(a^2+b^2)
m=discrete_log(res,base)
print(long_to_bytes(m))
```

#### 5.反方向的密码 相思

源代码：

```
from Crypto.Util.number import *

import hashlib

from secrets import flag





def hash(x):

  return hashlib.sha256(x.encode()).digest()





def pad(message):

  return message + hash(str(len(message)))





m = bytes_to_long(pad(flag))

p = getStrongPrime(512)

q = getStrongPrime(512)

n = p * q

e = 3

print(pow(m, e, n))

print(n)

\# 120440199294949712392334113337541924034371176306546446428347114627162894108760435789068328282135879182130546564535108930827440004987170619301799710272329673259390065147556073101312748104743572369383346039000998822862286001416166288971531241789864076857299162050026949096919395896174243383291126202796610039053

\# 143413213355903851638663645270518081058249439863120739973910994223793329606595495141951165221740599158773181585002460087410975579141155680671886930801733174300593785562287068287654547100320094291092508723488470015821072834947151827362715749438612812148855627557719115676595686347541785037035334177162406305243
```

也是一个非常熟悉的m低位泄露加copper

exp：

```
from Crypto.Util.number import *
import hashlib
def hash(x):
    return hashlib.sha256(x.encode()).digest()
def pad(message):
    return message + hash(str(len(message)))
c=120440199294949712392334113337541924034371176306546446428347114627162894108760435789068328282135879182130546564535108930827440004987170619301799710272329673259390065147556073101312748104743572369383346039000998822862286001416166288971531241789864076857299162050026949096919395896174243383291126202796610039053
n=143413213355903851638663645270518081058249439863120739973910994223793329606595495141951165221740599158773181585002460087410975579141155680671886930801733174300593785562287068287654547100320094291092508723488470015821072834947151827362715749438612812148855627557719115676595686347541785037035334177162406305243
e=3
for i in range(8,100):
    end=bytes_to_long(b'}'+hash(str(i)))
    begin=bytes_to_long(b'XYCTF{')
    R.<x>=PolynomialRing(Zmod(n))
    f=(begin*16^(66+2*i-14)+x*16^66+end)^e-c
    root = f.monic().small_roots(X=256^(i-7),beta = 0.4)
    if root:
        print(long_to_bytes(int(begin*16^(2*i-14)+root[0]))+b'}')
```

#### 
